"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkbloxu_browser"] = self["webpackChunkbloxu_browser"] || []).push([["services_player_pub_index_ts"],{

/***/ "../services/player/pub/index.ts":
/*!***************************************!*\
  !*** ../services/player/pub/index.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_browser_pub_WebWorker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../components/browser/pub/WebWorker */ \"../components/browser/pub/WebWorker.ts\");\n/* harmony import */ var _components_messaging_pub_MessagePipe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../components/messaging/pub/MessagePipe */ \"../components/messaging/pub/MessagePipe.ts\");\n/* harmony import */ var _components_messaging_pub_MessengerClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../components/messaging/pub/MessengerClass */ \"../components/messaging/pub/MessengerClass.ts\");\n/* harmony import */ var _local_Player__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./local/Player */ \"../services/player/pub/local/Player.ts\");\n/* harmony import */ var _remote_RemotePlayer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./remote/RemotePlayer */ \"../services/player/pub/remote/RemotePlayer.ts\");\n\n\n\n\n\nfunction main() {\n    var worker = new _components_browser_pub_WebWorker__WEBPACK_IMPORTED_MODULE_0__[\"default\"](self);\n    worker.onMessage((msg) => {\n        var player;\n        if (msg.type === \"request\" && msg.message.type === \"beMainPlayer\") {\n            player = new _local_Player__WEBPACK_IMPORTED_MODULE_3__[\"default\"](self.name);\n        }\n        else if (msg.type === \"request\" && msg.message.type === \"beRemotePlayer\") {\n            player = new _remote_RemotePlayer__WEBPACK_IMPORTED_MODULE_4__[\"default\"](self.name);\n        }\n        else if (msg.type === \"request\" && msg.message.type === \"beAIPlayer\") {\n            player = new _local_Player__WEBPACK_IMPORTED_MODULE_3__[\"default\"](self.name);\n            player.disableControls = true;\n        }\n        if (player !== undefined) {\n            let playerMessenger = new _components_messaging_pub_MessengerClass__WEBPACK_IMPORTED_MODULE_2__[\"default\"](player, player.proxyMessenger, self.name);\n            let pipe = new _components_messaging_pub_MessagePipe__WEBPACK_IMPORTED_MODULE_1__[\"default\"](worker, playerMessenger);\n            pipe.join();\n        }\n    });\n}\nmain();\n\n\n//# sourceURL=webpack://bloxu-browser/../services/player/pub/index.ts?");

/***/ }),

/***/ "../services/player/pub/local/Player.ts":
/*!**********************************************!*\
  !*** ../services/player/pub/local/Player.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Player)\n/* harmony export */ });\n/* harmony import */ var _components_messaging_pub_ProxyMessenger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../components/messaging/pub/ProxyMessenger */ \"../components/messaging/pub/ProxyMessenger.ts\");\n/* harmony import */ var _components_messaging_pub_MessageFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../components/messaging/pub/MessageFactory */ \"../components/messaging/pub/MessageFactory.ts\");\n/* harmony import */ var _components_messaging_pub_SyncMessenger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../components/messaging/pub/SyncMessenger */ \"../components/messaging/pub/SyncMessenger.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n/**\n * Class that contains the operations and state\n * of the LocalPlayer service.\n */\nclass Player {\n    constructor(playerId) {\n        this.playerId = playerId;\n        this.eventHandlers = {\n            \"IOService:<event>directionChange\": this.onControllerDirectionChange.bind(this),\n            \"IOService:<event>pointerTrigger\": this.onControllerPointerTrigger.bind(this),\n            \"IOService:<event>point\": this.onControllerPoint.bind(this),\n            \"IOService:<event>keyDown\": this.onControllerKeyDown.bind(this),\n            \"IOService:<event>keyUp\": this.onControllerKeyUp.bind(this),\n            \"World3D:Player:<event>projectileHit\": this.onBodyProjectileHit.bind(this),\n            \"World3D:Player:<event>hitDeathAltitude\": this.onBodyHitDeathAltitude.bind(this),\n            \"World3D:Player:<event>placeBlock\": this.onBodyPlaceBlock.bind(this),\n            \"World3D:Player:<event>shoot\": this.onBodyShoot.bind(this)\n        };\n        this.initialized = false;\n        this.spawned = false;\n        this.isAlive = true;\n        this.proxyMessenger = new _components_messaging_pub_ProxyMessenger__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n        this.syncMessenger = new _components_messaging_pub_SyncMessenger__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.proxyMessenger);\n        this.messageFactory = new _components_messaging_pub_MessageFactory__WEBPACK_IMPORTED_MODULE_1__[\"default\"](playerId);\n        this.disableControls = false;\n        this.disableEvents = false;\n    }\n    /**\n     * Id of the player body object in the world.\n     */\n    playerBodyId() {\n        return \"Player:PlayerBody?\" + this.playerId;\n    }\n    /**\n     * When the controller's pointer has changed position.\n     */\n    onControllerPoint(position, controllerIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.spawned) {\n                return;\n            }\n            if (this.disableControls) {\n                return;\n            }\n            const angle = (yield this.modifyWorld([this.playerBodyId(), position], function (bodyId, position) {\n                const body = this.getObject(bodyId);\n                body.point(new this.babylonjs.Vector2(position.x, position.y));\n                return body.bodyBuilder.topRotatable.angle;\n            }))[0];\n            this.proxyMessenger.postMessage(this.messageFactory.createEvent(\"*\", \"Player:<event>rotate\", [angle]));\n        });\n    }\n    /**\n     * When a key has been pressed down on the controller.\n     */\n    onControllerKeyDown(key, controllerIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (controllerIndex !== 0) {\n                return;\n            }\n            if (!this.spawned) {\n                return;\n            }\n            if (this.disableControls) {\n                return;\n            }\n            const inBattleState = (yield this.modifyWorld([this.playerBodyId(), key], function (bodyId, key) {\n                const body = this.getObject(bodyId);\n                body.pressFeatureKey(key);\n                return \"battle\" in body.actionModeStateMachine.activeStates;\n            }))[0];\n            if (key === \" \" && inBattleState) {\n                this.proxyMessenger.postMessage(this.messageFactory.createEvent(\"*\", \"Player:<event>jump\"));\n            }\n        });\n    }\n    /**\n     * When a pressed down key has been released on the controller.\n     */\n    onControllerKeyUp(key, controllerIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (controllerIndex !== 0) {\n                return;\n            }\n            if (!this.spawned) {\n                return;\n            }\n            if (this.disableControls) {\n                return;\n            }\n            this.modifyWorld([this.playerBodyId(), key], function (bodyId, key) {\n                const body = this.getObject(bodyId);\n                body.releaseFeatureKey(key);\n            });\n        });\n    }\n    /**\n     * When a pointer control has been pressed down (e.g. a mouse button).\n     */\n    onControllerPointerTrigger(position, buttonIndex, controllerIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (buttonIndex !== 0) {\n                return;\n            }\n            if (controllerIndex !== 0) {\n                return;\n            }\n            if (!this.spawned) {\n                return;\n            }\n            if (this.disableControls) {\n                return;\n            }\n            const state = (yield this.syncMessenger.postSyncMessage(this.messageFactory.createRequest(\"world3d\", \"modify\", [\n                {\n                    boundArgs: [this.playerBodyId()],\n                    f: function (bodyId) {\n                        const body = this.getObject(bodyId);\n                        body.doMainAction();\n                    }\n                }\n            ])))[0];\n            // Send a message to the environment that the player has shot.\n            this.proxyMessenger.postMessage(this.messageFactory.createEvent(\"*\", \"Player:<event>shoot\", [state]));\n        });\n    }\n    /**\n     * Does what Player wants to do when the controller's main\n     * direction control has changed (for example, the thumb joystick or WASD keys).\n     */\n    onControllerDirectionChange(direction, controllerIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.disableControls) {\n                return;\n            }\n            if (controllerIndex !== 0) {\n                return;\n            }\n            if (this.initialized && this.spawned) {\n                // Move the player's body in the controller's direction.\n                const directionEvent = (yield this.syncMessenger.postSyncMessage({\n                    sender: this.playerId,\n                    recipient: \"world3d\",\n                    type: \"request\",\n                    message: {\n                        type: \"modify\",\n                        args: [{\n                                boundArgs: [this.playerBodyId(), direction],\n                                f: function (bodyId, direction) {\n                                    const body = this.getObject(bodyId);\n                                    const directionVector = new this.babylonjs.Vector2(direction.x, direction.y);\n                                    body.move(directionVector);\n                                    return {\n                                        direction: direction,\n                                        body: body.state()\n                                    };\n                                }\n                            }]\n                    }\n                }))[0];\n                // Send a message to the environment that the player has changed movement direction.\n                this.proxyMessenger.postMessage(this.messageFactory.createEvent(\"*\", \"Player:<event>move\", [directionEvent]));\n            }\n            return this;\n        });\n    }\n    /**\n     * Initialization procedure for the LocalPlayer service.\n     */\n    initialize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.initialized = true;\n            return true;\n        });\n    }\n    /**\n     * Spawn the player's body at the given position.\n     */\n    spawn(startingPosition) {\n        // Create the player's body.\n        this.proxyMessenger.postMessage(this.messageFactory.createRequest(\"world3d\", \"createObject\", [\n            this.playerBodyId(),\n            \"PlayerBody\",\n            {\n                boundArgs: [this.playerBodyId(), startingPosition],\n                f: function (playerBodyId, startingPosition) {\n                    // Determine the arguments passed to PlayerBody's constructor.\n                    return [\n                        playerBodyId,\n                        startingPosition,\n                        this.scene,\n                        this.meshConstructors\n                    ];\n                }\n            }\n        ]));\n        if (this.disableControls) {\n            // Disable UI of body.\n            this.proxyMessenger.postMessage(this.messageFactory.createRequest(\"world3d\", \"modifyObject\", [\n                this.playerBodyId(),\n                {\n                    boundArgs: [],\n                    f: function (body) {\n                        body.disableUI();\n                        return body;\n                    }\n                }\n            ]));\n        }\n        // Set event listeners.\n        this.proxyMessenger.postMessage(this.messageFactory.createRequest(\"world3d\", \"listen\", [\n            this.playerId,\n            {\n                boundArgs: [this.playerBodyId(), this.disableEvents],\n                f: function (sendMsg, playerBodyId, disableEvents) {\n                    const playerBody = this.getObject(playerBodyId);\n                    // If the player service should be disconnected \n                    // from any controls (such as the keyboard or mouse) \n                    // then we do not want to set the related event listeners.\n                    if (!disableEvents) {\n                        // Let the player's body handle updating its own \n                        // objects.\n                        playerBody.enableAutoUpdate();\n                        // Get notifications of when the player character gets hit with a projectile.\n                        playerBody.emitter.on(\"projectileHit\", () => {\n                            sendMsg(\"World3D:Player:<event>projectileHit\", playerBody.state());\n                        });\n                        // Get notifications of when the player character reaches a death altitude (i.e. dies by falling).\n                        playerBody.emitter.on(\"hitDeathAltitude\", () => {\n                            sendMsg(\"World3D:Player:<event>hitDeathAltitude\", playerBody.state());\n                        });\n                        // Listen to block placement events.\n                        const buildState = playerBody.actionModeStateMachine.states[\"build\"];\n                        const placementGrid = buildState.placeMeshState.eventablePlacementGrid;\n                        placementGrid.emitter.on(\"place\", (cell, absolutePosition) => {\n                            sendMsg(\"World3D:Player:<event>placeBlock\", {\n                                cell: { x: cell.x, y: cell.y, z: cell.z },\n                                absolutePosition: { x: absolutePosition.x, y: absolutePosition.y, z: absolutePosition.z }\n                            });\n                        });\n                        // Listen to gun shot events.\n                        const shootState = playerBody.actionStateMachine.states[\"shoot\"];\n                        shootState.emitter.on(\"shoot\", (direction) => {\n                            sendMsg(\"World3D:Player:<event>shoot\", {\n                                direction: { x: direction.x, y: direction.y, z: direction.z },\n                                body: playerBody.state()\n                            });\n                        });\n                    }\n                }\n            }\n        ]));\n        this.spawned = true;\n        return true;\n    }\n    /**\n     * Sets the state of the Player character's body.\n     */\n    setState(state) {\n        if (!this.spawned) {\n            return;\n        }\n        this.proxyMessenger.postMessage(this.messageFactory.createRequest(\"world3d\", \"modify\", [\n            {\n                boundArgs: [this.playerBodyId(), state],\n                f: function (bodyId, state) {\n                    const body = this.getObject(bodyId);\n                    body.setState(state);\n                }\n            }\n        ]));\n    }\n    /**\n     * When the Player's player body has rotated in the world.\n     * This is an event that occurs only if the Player's controls are not\n     * disabled.\n     */\n    onBodyProjectileHit(state) {\n        this.die();\n    }\n    /**\n     * When the player's body has hit an altitude\n     * at which the player should die.\n     */\n    onBodyHitDeathAltitude() {\n        this.die();\n    }\n    /**\n     * When the player's body has placed a block.\n     */\n    onBodyPlaceBlock(event) {\n        this.proxyMessenger.postMessage(this.messageFactory.createEvent(\"*\", \"Player:<event>placeBlock\", [event.absolutePosition]));\n    }\n    /**\n     * When the player's body has placed a block.\n     */\n    onBodyShoot(event) {\n        this.proxyMessenger.postMessage(this.messageFactory.createEvent(\"*\", \"Player:<event>shoot\", [event]));\n    }\n    /**\n     * Causes the player to die if alive.\n     */\n    die() {\n        if (this.isAlive) {\n            this.isAlive = false;\n            // Notify the service's environment that the player has died.\n            this.proxyMessenger.postMessage(this.messageFactory.createEvent(\"*\", \"Player:<event>die\", [this.playerId]));\n        }\n    }\n    /**\n     * Sets the player's rotation angle.\n     */\n    setAngle(angle) {\n        if (!this.spawned) {\n            return;\n        }\n        this.modifyWorld([angle, this.playerBodyId()], function (angle, bodyId) {\n            const body = this.getObject(bodyId);\n            body.setAngle(angle);\n        });\n    }\n    /**\n     * Place a block at the given absolute position in the world.\n     */\n    placeBlockAbsolute(absolutePosition) {\n        if (!this.spawned) {\n            return;\n        }\n        this.modifyWorld([absolutePosition, this.playerBodyId()], function (absolutePosition, bodyId) {\n            const body = this.getObject(bodyId);\n            body.placeBlockAbsolute(new this.babylonjs.Vector3(absolutePosition.x, absolutePosition.y, absolutePosition.z));\n        });\n    }\n    /**\n     * Call 'modify' on world3d.\n     */\n    modifyWorld(boundArgs, f) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.syncMessenger.postSyncMessage(this.messageFactory.createRequest(\"world3d\", \"modify\", [\n                {\n                    boundArgs: boundArgs,\n                    f: f\n                }\n            ]));\n        });\n    }\n}\n\n\n//# sourceURL=webpack://bloxu-browser/../services/player/pub/local/Player.ts?");

/***/ }),

/***/ "../services/player/pub/remote/RemotePlayer.ts":
/*!*****************************************************!*\
  !*** ../services/player/pub/remote/RemotePlayer.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RemotePlayer)\n/* harmony export */ });\n/* harmony import */ var _local_Player__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../local/Player */ \"../services/player/pub/local/Player.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n/**\n * A Player that is controlled remotely by another online player.\n */\nclass RemotePlayer {\n    constructor(playerId) {\n        this.player = new _local_Player__WEBPACK_IMPORTED_MODULE_0__[\"default\"](playerId);\n        this.player.disableControls = true;\n        this.player.disableEvents = true;\n        this.proxyMessenger = this.player.proxyMessenger;\n        this.syncMessenger = this.player.syncMessenger;\n        this.messageFactory = this.player.messageFactory;\n        this.eventHandlers = {\n            \"OnlineSynchronizer:Player:<event>move\": this.onRemoteMove.bind(this),\n            \"OnlineSynchronizer:Player:<event>shoot\": this.onRemoteShoot.bind(this),\n            \"OnlineSynchronizer:Player:<event>rotate\": this.onRemoteRotate.bind(this),\n            \"OnlineSynchronizer:Player:<event>die\": this.onRemoteDie.bind(this),\n            \"OnlineSynchronizer:Player:<event>placeBlock\": this.onRemotePlaceBlock.bind(this),\n            \"OnlineSynchronizer:Player:<event>jump\": this.onRemoteJump.bind(this),\n        };\n    }\n    /**\n     * Initialize RemotePlayer service.\n     */\n    initialize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.player.initialize();\n        });\n    }\n    spawn(startingPosition) {\n        return this.player.spawn(startingPosition);\n    }\n    /**\n     * When a controller direction event has been\n     * received, e.g. a joystick event.\n     */\n    onRemoteMove(event) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Invert the direction vector, since the remote player's \n            // orientation for controls is the opposite \n            // of the local player's.\n            event.direction = { x: (-1) * event.direction.x, y: (-1) * event.direction.y };\n            // Move the player's body in the controller's direction.\n            yield this.player.modifyWorld([this.player.playerBodyId(), event], function (bodyId, event) {\n                const body = this.getObject(bodyId);\n                const jumpState = body.actionStateMachine.states[\"jump\"];\n                // We only want to force-update the state of the body \n                // if we are not currently jumping. Force-updating state \n                // during jumping often causes jumping to end prematurely.\n                if (!jumpState.isActive) {\n                    // Update the body's state in the world \n                    // to mirror the state the real player had at the time of the event.\n                    body.setState(event.body);\n                }\n                const directionVector = new this.babylonjs.Vector2(event.direction.x, event.direction.y);\n                body.move(directionVector);\n                // Return something because SyncMessenger \n                // requires that the receiving service returns a response.\n                // ClassMessenger on the other hand only returns a \n                // response if the called function on the wrapped class returns something.\n                // The World3D service class is wrapped in a ClassMessenger.\n                // Thus, if we do not return anything here, we will not receive a response.\n                return true;\n            });\n        });\n    }\n    /**\n     * When the real player represented by the RemotePlayer has shot in their game.\n     */\n    onRemoteShoot(event) {\n        // Update the player's state in the world \n        // to mirror the state the real player had at the time of the event.\n        this.player.setState(event.body);\n        // Now shoot in the direction given in the event.\n        this.player.proxyMessenger.postMessage(this.player.messageFactory.createRequest(\"world3d\", \"modify\", [\n            {\n                boundArgs: [this.player.playerBodyId(), event.direction],\n                f: function (bodyId, direction) {\n                    const body = this.getObject(bodyId);\n                    const shootState = body.actionStateMachine.states[\"shoot\"];\n                    if (!shootState.isActive) {\n                        body.actionStateMachine.resourceStateMachine\n                            .transferResourcesFromAll(\"shoot\", new Set(Array.from(shootState.wantedResources)));\n                        shootState.shoot(new this.babylonjs.Vector3(direction.x, direction.y, direction.z));\n                    }\n                }\n            }\n        ]));\n    }\n    /**\n     * When the player body's state has changed and\n     * we simply wish to update it.\n     */\n    onSimpleStateChange(state) {\n        this.player.setState(state);\n    }\n    /**\n     * When the player has died in their game.\n     */\n    onRemoteDie() {\n        // Tell the environment that the remote player has died.\n        this.player.proxyMessenger.postMessage(this.player.messageFactory.createEvent(\"*\", \"Player:<event>die\", [this.player.playerId]));\n    }\n    /**\n     * When the remote player has rotated.\n     */\n    onRemoteRotate(angle) {\n        this.player.setAngle(angle);\n    }\n    /**\n     * When the remote player has placed a block.\n     */\n    onRemotePlaceBlock(absolutePosition) {\n        this.player.placeBlockAbsolute(absolutePosition);\n    }\n    /**\n     * When the remote player has jumped.\n     */\n    onRemoteJump() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.player.disableControls = false;\n            yield this.player.onControllerKeyDown(\" \", 0);\n            this.player.disableControls = true;\n        });\n    }\n}\n\n\n//# sourceURL=webpack://bloxu-browser/../services/player/pub/remote/RemotePlayer.ts?");

/***/ })

}]);